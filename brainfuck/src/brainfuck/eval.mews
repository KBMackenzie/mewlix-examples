yarn ball brainfuck.eval

from brainfuck.ast takes TokenType
from brainfuck.env takes Environment

mew Instructions = std.table()                                                                \
  .add(TokenType.MoveLeft  , =^oxo^= (env, token) => env.move(-token.count)   )               \
  .add(TokenType.MoveRight , =^oxo^= (env, token) => env.move(token.count)    )               \
  .add(TokenType.Increment , =^oxo^= (env, token) => env.modify(token.count)  )               \
  .add(TokenType.Decrement , =^oxo^= (env, token) => env.modify(-token.count) )               \
  .add(TokenType.Puts      , =^oxo^= (env, token) => puts(env, token.count)   )               \
  .add(TokenType.Gets      , =^oxo^= (env, token) => gets(env, token.count)   )               \
  .add(TokenType.Loop      , =^oxo^= (env, token) => loop(token.block, env)   )

=^.x.^= evaluate(tokens, env_arg)
  mew env = env_arg or new Environment()
  it's raining tokens!! catch a token!!
    evaluate_token(token, env)
  meowmeow
  bring env.get_output()
meowmeow

=^.x.^= puts(env, count)
  stare while count > 0
    env.puts()
    count = count - 1
  meowmeow
meowmeow

=^.x.^= gets(env, count)
  stare while count > 0
    env.gets()
    count = count - 1
  meowmeow
meowmeow

=^.x.^= loop(tokens, env)
  stare while env.look() > 0
    evaluate(tokens, env)
  meowmeow
meowmeow

=^.x.^= evaluate_token(token, env)
  peek if Instructions.has(token.type)
    bring Instructions.get(token.type)(env, token)
  meowmeow

  throw :3"Unrecognized instruction: [token.type]"
meowmeow
